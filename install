#!/usr/bin/env python
from __future__ import print_function
import argparse
import functools
import os
import os.path
import subprocess
import contextlib
import copy
from sys import platform


# TERMINAL COLORS
class Colors:
    reset = '\033[0m'
    bold = '\033[01m'
    disable = '\033[02m'
    underline = '\033[04m'
    reverse = '\033[07m'
    strikethrough = '\033[09m'
    invisible = '\033[08m'

    fg_black = '\033[30m'
    fg_red = '\033[31m'
    fg_green = '\033[32m'
    fg_orange = '\033[33m'
    fg_blue = '\033[34m'
    fg_purple = '\033[35m'
    fg_cyan = '\033[36m'
    fg_lightgrey = '\033[37m'
    fg_darkgrey = '\033[90m'
    fg_lightred = '\033[91m'
    fg_lightgreen = '\033[92m'
    fg_yellow = '\033[93m'
    fg_lightblue = '\033[94m'
    fg_pink = '\033[95m'
    fg_lightcyan = '\033[96m'

    bg_black = '\033[40m'
    bg_red = '\033[41m'
    bg_green = '\033[42m'
    bg_orange = '\033[43m'
    bg_blue = '\033[44m'
    bg_purple = '\033[45m'
    bg_cyan = '\033[46m'
    bg_lightgrey = '\033[47m'


# ASCII ART
ASCII_ART = """
{}--------------------------------------------------
       __      __  _____ __
  ____/ /___  / /_/ __(_) /__  _____
 / __  / __ \/ __/ /_/ / / _ \/ ___/
/ /_/ / /_/ / /_/ __/ / /  __(__  )
\__,_/\____/\__/_/ /_/_/\___/____/


Author: Ha Junsoo
Repository: https://github.com/kuc2477/dotfiles
Supported Languages: Python, JavaScript, Haskell
Supported Platforms: OS X, Debian
Dependencies: Python, Bash, curl, git

--------------------------------------------------{}
""".format(Colors.bold, Colors.reset)


# SHELL
SHELL = '/bin/bash'

# UPSTREAM SOURCES
FZF_URL = 'https://github.com/junegunn/fzf.git'
HTOP_URL = 'https://hisham.hm/htop/releases/2.0.2/htop-2.0.2.tar.gz'
STACK_URL = 'https://get.haskellstack.org/'
NVM_URL = 'https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh'
PYENV_URL = (
    'https://raw.githubusercontent.com/yyuu/pyenv-installer'
    '/master/bin/pyenv-installer'
)
PLUG_URL = (
    'https://raw.githubusercontent.com/junegunn/vim-plug'
    '/master/plug.vim'
)
SEOUL256_GNOME_URL = (
    'https://github.com/anuragsoni/seoul256-gnome-terminal.git'
)
SEOUL256_ITERM_URL = (
    'https://github.com/mikker/seoul256-iTerm.git'
)

# SYSTEM SPECIFIC CONFIGURATIONS
SYSTEM_SPECIFIC_INSTALLER = {
    'osx': 'brew install',
    'debian': 'sudo apt-get install -y'
}
SYSTEM_SPECIFIC_NAMES = {
    'ag': {
        'osx': 'the_silver_searcher',
        'debian': 'silversearcher-ag'
    },
    'libevent': {
        'osx': 'libevent',
        'debian': 'libevent-dev'
    },
    'ctags': {
        'osx': 'ctags',
        'debian': 'exuberant-ctags'
    },
    'bashrc': {
        'osx': '.profile',
        'debian': '.bashrc'
    },
    'neovim': {
        'osx': 'neovim/neovim/neovim',
        'debian': 'neovim'
    },
    'python-pip': {'osx': None},
    'python3-pip': {'osx': None},
    'curl': {'osx': None},
    'jid': {'debian': None},
}


# ================
# UTILITIES (CODE)
# ================

def _header(string, margin_top=True, margin_bottom=False):
    margin_top = '\n' if margin_top else ''
    margin_bottom = '\n' if margin_bottom else ''
    divider = '=' * len(string)
    return (
        margin_top +
        divider + '\n' +
        string + '\n' +
        divider +
        margin_bottom
    )


def _breadcrumb(breadcrumb, include_current=False):
    marker = '->'
    depth = len(breadcrumb)
    if include_current:
        return '[{}] '.format((marker.join(breadcrumb))) if depth > 0 else ''
    else:
        return '[{}] '.format(marker.join(breadcrumb[:depth-1])) \
            if depth > 1 else ''


def _style(string, styles=None, stdout=True):
    # apply styles
    styles = styles or []
    styled = '{}{}'.format(string, Colors.reset)
    for style in styles:
        styled = getattr(Colors, style.lower()) + styled

    # print to stdout
    if stdout:
        print(styled)

    # return styled string
    return styled


@contextlib.contextmanager
def _log_command_with_dependencies(f, dependencies, breadcrumb):
    name = f.__name__
    name_stripped = name.lstrip('_')
    dependencies_stripped = [n.lstrip('_') for n in dependencies]
    breadcrumb_stripped = [n.lstrip('_') for n in breadcrumb]
    is_root = len(breadcrumb) == 1

    # display installation information on start
    if dependencies and is_root:
        _style(_header('{}Installing {} with dependencies: {}'.format(
            _breadcrumb(breadcrumb_stripped), name_stripped,
            dependencies_stripped
        ), margin_top=False), ['fg_cyan', 'bold'])

    yield


@contextlib.contextmanager
def _log_command(f, breadcrumb):
    name_stripped = f.__name__.lstrip('_')
    breadcrumb_stripped = [n.lstrip('_') for n in breadcrumb]

    # styles
    start_styles = ['fg_yellow', 'bold']
    end_styles = ['bold']

    # display installation information on start
    _style(_header('{}Installing {}'.format(
        _breadcrumb(breadcrumb_stripped), name_stripped
    )), start_styles)

    yield

    # display installation information on done
    _style('\n# Installed {}!'.format(name_stripped), end_styles)


def _system():
    return 'osx' if _is_osx() else 'debian'


def _is_osx():
    return platform == 'darwin'


def _system_specific_name(name, system):
    try:
        return SYSTEM_SPECIFIC_NAMES[name][system]
    except KeyError:
        return name


def _none_or_empty(command):
    is_none = command is None
    empty_string = isinstance(command, str) and len(command.strip()) == 0
    empty_iterable = (isinstance(command, (list, tuple)) and len(command) == 0)
    return is_none or empty_string or empty_iterable


def _ran(target_name):
    return registry[target_name].ran


def _run(command):
    _run_maybe_thunk_command = (
        lambda c: os.system(c()) if callable(c) and c()
        else c and os.system(c)
    )
    if isinstance(command, (list, tuple)):
        for c in command:
            _run_maybe_thunk_command(c)
    else:
        _run_maybe_thunk_command(command)


def _stdout(command):
    return subprocess.check_output(command, shell=True).strip()


# ===================
# UTILITIES (COMMAND)
# ===================

def _in_nvm(command, version='node'):
    return '. ~/.nvm/nvm.sh && nvm use {} && ({})'.format(version, command)


def _install_system_packages(package, *packages):
    system = _system()
    installer = SYSTEM_SPECIFIC_INSTALLER[system]
    system_specific_package_names = [
        _system_specific_name(name, system)
        for name in [package] + list(packages)
        if _system_specific_name(name, system) is not None
    ]

    return '{} {}'.format(installer, ' '.join([
        n for n in system_specific_package_names
    ]))


def _sudo_on_system(command, system):
    maybe_sudo = 'sudo ' if system == _system() else ''
    return '{}{}'.format(maybe_sudo, command)


def _exists(path):
    return os.path.exists(os.path.expanduser(path))


def _if_no_command(name, command):
    return 'command -v {} >/dev/null || ({})'.format(name, command)


def _link(path, to, rel=True, sudo=False):
    if rel:
        return '{} ln -sf `pwd`/{} {}'.format('sudo' if sudo else '', path, to)
    else:
        return '{} ln -sf {} {}'.format('sudo' if sudo else '', path, to)


# ===========================
# TARGET REGISTRY / DECORATOR
# ===========================

# TARGET REGISTRY
registry = {}


# TARGET DECORATOR
def target(*args):
    assert (
        (len(args) == 1 and isinstance(args[0], list)) or
        (len(args) == 1 and callable(args[0]))
    )

    # determine dependencies from given arguements
    dependencies = [] if callable(args[0]) else args[0]

    # wrapped function runs dependencies before the function itself.
    def create_wrapped(f):
        @functools.wraps(f)
        def wrapped(breadcrumb=None):
            # dependency breadcrumb
            name = f.__name__
            breadcrumb = copy.deepcopy(breadcrumb) or []
            breadcrumb += [name]

            # print installation target information
            with _log_command_with_dependencies(f, dependencies, breadcrumb):
                for dep in dependencies:
                    # run dependencies
                    install_target = registry[dep]
                    install_command = install_target.command
                    has_dependencies = install_target.dependencies
                    not_ran = not _ran(dep)
                    not_none_or_empty = not _none_or_empty(install_command)
                    if not_ran and (not_none_or_empty or has_dependencies):
                        install_target(breadcrumb)
                else:
                    # run the command itself and mark after execution
                    install_command = f()
                    not_ran = not _ran(name)
                    not_none_or_empty = not _none_or_empty(install_command)
                    if not_ran and not_none_or_empty:
                        with _log_command(f, breadcrumb):
                            _run(install_command)
                            registry[name].ran = True

        wrapped.command = f()
        wrapped.dependencies = dependencies
        return wrapped

    # return decorator in case of target with dependencies
    if dependencies:
        def decorator(f):
            wrapped = create_wrapped(f)
            registry[f.__name__] = wrapped
            registry[f.__name__].ran = False
            return wrapped
        return decorator
    # return wrapped function in case of zero dependencies
    else:
        wrapped = create_wrapped(args[0])
        registry[args[0].__name__] = wrapped
        registry[args[0].__name__].ran = False
        return wrapped


# ==============
# TARGETS (MAIN)
# ==============

@target(['vim', 'utils', 'shell'])
def all():
    pass


@target(['_system_python', '_submodules', '_font'])
def shell():
    # powerline
    get_powerline_root_dir = (lambda: _stdout(
        'pip show powerline-status | '
        'grep -i location | grep -Eo /.*$'
    ))
    get_powerline_bash_binding_path = (
        lambda: '{}/powerline/bindings/bash/powerline.sh'.format(
            get_powerline_root_dir()
        )
    )
    powerline_config_dir = '{}/bash/powerline-configs'.format(_stdout('pwd'))

    # seoul256
    if _is_osx():
        install_seoul256_path = '~/.config/seoul256-gnome-terminal'
        install_seoul256 = (
            'git clone {url} {path}'
            '. {path}/seoul256-dark.sh'
        ).format(url=SEOUL256_GNOME_URL, path=install_seoul256_path) \
            if _exists(install_seoul256_path) else None
    else:
        install_seoul256_path = '~/.config/seoul256-iTerm'
        install_seoul256 = (
            'git clone {url} {path}'
        ).format(url=SEOUL256_ITERM_URL, path=install_seoul256_path) \
            if _exists(install_seoul256_path) else None

    # gogh
    install_gogh = '{} && {}'.format(
        _install_system_packages('dconf-cli'),
        ('wget -O gogh https://git.io/vKOB6 && chmod +x gogh && '
         'mv ./gogh /usr/local/bin')
    ) if not _is_osx() else None

    return [
        # powerline
        'pip install powerline-status powerline-gitstatus',
        'mkdir -p ~/.config/powerline/colorschemes',
        'mkdir -p ~/.config/powerline/themes/shell',
        (lambda: _link(get_powerline_bash_binding_path(),
                       '~/.powerline', rel=False)),
        _link(
            '{}/config.json'.format(powerline_config_dir),
            '~/.config/powerline/config.json', rel=False
        ),
        _link(
            '{}/colorscheme.json'.format(powerline_config_dir),
            '~/.config/powerline/colorschemes/default.json', rel=False
        ),
        _link(
            '{}/theme.json'.format(powerline_config_dir),
            '~/.config/powerline/themes/shell/default.json', rel=False
        ),
        # seoul256
        install_seoul256,
        # gogh
        install_gogh,
        # autocompletions
        _install_system_packages('bash-completion'),
        _link(
            'bash/autocompletions/git-completion.bash',
            '~/.git-completion.bash',
        ),
        _link(
            'bash/autocompletions/docker-completion.bash',
            '~/.docker-completion.bash'
        ),
        _link(
            'bash/autocompletions/docker-compose-completion.bash',
            '~/.docker-compose-completion.bash'
        ),
        _link(
            'bash/autocompletions/tmux-completion.bash',
            '~/.tmux-completion.bash'
        ),
        # bash configuration
        _link('bash/bashrc', '~/{}'.format(
            SYSTEM_SPECIFIC_NAMES['bashrc'][_system()]))
    ]


@target(['_vim_deps'])
def vim():
    if _is_osx():
        prepare_vim_registry = ['brew tap neovim/neovim']
    else:
        prepare_vim_registry = [
            'sudo add-apt-repository ppa:neovim-ppa/stable --yes',
            'sudo apt-get update'
        ]

    return prepare_vim_registry + [
        _install_system_packages('neovim'),
        'curl -fLo ~/.vim/autoload/plug.vim --create-dirs {}'.format(PLUG_URL),
        'mkdir -p ~/.config/nvim',
        _link('vim/init.vim', '~/.config/nvim/init.vim'),
        _link('vim/vimrc.vim', '~/.vimrc'),
        _link('vim/snippets', '~/.snippets'),
        'nvim +PlugInstall +VimProcInstall +qall',
    ]


@target(['_system_python', '_javascript', '_tmux'])
def utils():
    # scripts
    scripts = [
        'bin/rmswp',
        'bin/tpd',
        'bin/rmpyc'
    ]
    install_scripts = [_link(s, '/usr/local/bin', sudo=True) for s in scripts]

    # system dependencies
    install_system_dependencies = _install_system_packages(
        'libwebp-dev',
        'libgraphicsmagick++-dev'
    )

    # timg
    install_timg = _if_no_command('timg', (
        'git clone https://github.com/hzeller/timg.git &&'
        'cd timg/src &&'
        'make &&'
        'sudo make install &&'
        'cd .. && '
        'cd .. && '
        'rm -rf ./timg'
    ))

    # pgweb
    if _is_osx():
        install_pgweb = 'brew cask install pgweb'
    else:
        install_pgweb = _link('bin/pgweb', '/usr/local/bin', sudo=True)

    # fzf
    install_fzf = (
        'git clone --depth 1 {} ~/.fzf && ~/.fzf/install --all'
        .format(FZF_URL) if not os.path.exists(os.path.expanduser('~/.fzf'))
        else None
    )

    # htop 2.02
    install_htop = ((
        'sudo apt install libncursesw5-dev && '
        'wget {HTOP_URL} && '
        'tar xzf htop-2.0.2.tar.gz && '
        'rm htop-2.0.2.tar.gz && '
        'cd htop-2.0.2 && '
        './configure && make && sudo make install && '
        'cd .. && '
        'rm -rf htop-2.0.2'
    ).format(HTOP_URL=HTOP_URL))

    commands = install_scripts + [
        install_system_dependencies,
        install_timg,
        install_pgweb,
        install_fzf,
        install_htop,
        'sudo pip install autoenv pgcli saws TermFeed http-prompt',
        'sudo pip3 install khal',
        _in_nvm('npm install -g git-standup tiny-care-terminal'),
        _install_system_packages(
            'cowsay', 'fortune', 'toilet', 'autojump', 'task', 'pv', 'jq',
            'jid', 'httpie', 'ag', 'ranger', 'tig', 'irssi'
        ),
    ]

    return (
        commands if _is_osx() else
        commands + [_install_system_packages(
            'xdg-utils', 'gnome-tweak-tool', 'geary',
        )]
    )


# ======================
# TARGETS (DEPENDENCIES)
# ======================

@target(['_submodules'])
def _font():
    return 'fonts/install.sh'


@target
def _submodules():
    return 'git submodule update --init'


@target
def _system_python():
    return _install_system_packages(
        'python', 'python3', 'python-pip', 'python3-pip'
    )


@target(['_system_python'])
def _powerline_status():
    return 'pip install powerline-status powerline-gitstatus'


@target(['_system_python', '_python', '_javascript', '_haskell', '_font'])
def _vim_deps():
    return [
        _install_system_packages('bashdb', 'cmake', 'ctags'),
        'pip install neovim',
        'pip3 install neovim'
    ]


@target(['_system_python', '_submodules', '_font'])
def _tmux():
    if _is_osx():
        deps = [
            'pkg-config', 'libevent', 'automake',
            'reattach-to-user-namespace'
        ]
    else:
        deps = [
            'pkg-config', 'libevent', 'automake',
            'libncurses-dev'
        ]

    compile_tmux = (
        'cd tmux/tmux-src && ./autogen.sh && ./configure && '
        'make && sudo make install'
    )

    return [
        _install_system_packages(*deps),
        _if_no_command('tmux', compile_tmux),
        _link('tmux/tmux', '~/.tmux'),
        _link('tmux/tmux.conf', '~/.tmux.conf'),
        _link('tmux/tmux-powerline', '~/.tmux-powerline'),
        _link('tmux/tmux-powerlinerc', '~/.tmux-powerlinerc'),
    ]


@target(['_system_python'])
def _python():
    if _is_osx():
        install_pyenv = 'brew update && brew install pyenv pyenv-virtualenv'
    else:
        install_pyenv = '{} && (curl -L {} | bash)'.format(
            _install_system_packages(
                'make', 'build_essential', 'libssl-dev', 'zlib1g-dev',
                'libbz2-dev', 'libreadline-dev', 'libsqlite3-dev', 'wget',
                'curl', 'llvm', 'libncurses5-dev'
            ), PYENV_URL
        )

    return [
        _if_no_command('pyenv', install_pyenv),
        _link('python/pypirc', '~/.pypirc'),
        _link('python/pythonrc.py', '~/.pythonrc.py'),
        _link('python/pdbrc.py', '~/.pdbrc.py'),
    ]


@target
def _javascript():
    return [
        _if_no_command('nvm', 'curl -o- {} | bash'.format(NVM_URL)),
        '. ~/.nvm/nvm.sh && nvm install node',
        '. ~/.nvm/nvm.sh && nvm use node',
        _link('javascript/tern-project', '~/.tern-project'),
    ]


@target
def _haskell():
    return [
        _if_no_command('stack', 'curl -sSL {} | sh'.format(STACK_URL)),
        'stack setup',
    ]


# ====
# MAIN
# ====

# PARSER
parser = argparse.ArgumentParser('cli for dotfile installation')
parser.add_argument(
    'target', metavar='NAME', type=str, nargs='?', default='all',
    choices=['all', 'vim', 'utils', 'shell'],
    help='target to install'
)


if __name__ == '__main__':
    print(ASCII_ART)
    args = parser.parse_args()
    registry[args.target]()
